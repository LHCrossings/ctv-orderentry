"""
SAGENT Order PDF Parser

Parses SAGENT orders generated by GaleForceMedia system.

Key Features:
- Multi-market orders (CVC, LAX, SFO, etc.)
- Weekly spot distribution across flight dates
- Rate grossing: Net rates must be divided by 0.85
- Order # goes in Customer Order Ref field
- Estimate # stripped of leading zeros for contract naming

PDF Structure:
- Header: Advertiser, Campaign, Flight Dates, Order #, Estimate #
- Lines: Time Period, Days, Length, Net Rate, Network (Market), Program (Language)
- Weekly columns: Show spot distribution by week
- Bonus lines: $0.00 net rate
"""

from dataclasses import dataclass
from typing import List, Optional, Tuple
from datetime import datetime, date
from decimal import Decimal, ROUND_HALF_UP
import pdfplumber
import re


@dataclass(frozen=True)
class SagentLine:
    """
    A single line item from SAGENT order.
    
    Attributes:
        line_number: Line number from PDF
        time_period: Time range (e.g., "6:00A to 11:59P")
        days: Day pattern (e.g., "M T W R F Sa Su")
        length: Spot duration (e.g., ":15", ":30")
        net_rate: Net rate from PDF (before grossing)
        gross_rate: Grossed rate (net_rate / 0.85)
        market: Market code (e.g., "CVC", "LA", "SFO")
        program: Program/Language (e.g., "CHINESE", "FILIPINO")
        weekly_spots: List of spots per week
        total_spots: Total spots across all weeks
    """
    line_number: int
    time_period: str
    days: str
    length: str
    net_rate: Decimal
    gross_rate: Decimal
    market: str
    program: str
    weekly_spots: List[int]
    total_spots: int
    
    def is_bonus(self) -> bool:
        """Check if this is a bonus line ($0.00 rate)."""
        return self.net_rate == Decimal("0.00")
    
    def get_duration_seconds(self) -> int:
        """Convert length to seconds (e.g., ':15' -> 15, ':30' -> 30)."""
        match = re.search(r':(\d+)', self.length)
        if match:
            return int(match.group(1))
        return 15  # Default
    
    def get_etere_days(self) -> str:
        """
        Convert day pattern to Etere format.
        
        Examples:
            "M T W R F Sa Su" -> "M-Su"
            "M T W R F" -> "M-F"
        """
        # Map day abbreviations
        day_map = {
            'M': 'M', 'T': 'T', 'W': 'W', 'R': 'R', 
            'F': 'F', 'Sa': 'Sa', 'Su': 'Su'
        }
        
        days_list = self.days.split()
        
        # Check for M-Su (all 7 days)
        if len(days_list) == 7 and days_list == ['M', 'T', 'W', 'R', 'F', 'Sa', 'Su']:
            return "M-Su"
        
        # Check for M-F (weekdays)
        if days_list == ['M', 'T', 'W', 'R', 'F']:
            return "M-F"
        
        # Check for Sa-Su (weekends)
        if days_list == ['Sa', 'Su']:
            return "Sa-Su"
        
        # Otherwise, return as-is with spaces
        return self.days
    
    def get_etere_time(self) -> str:
        """
        Convert time period to Etere format.
        
        Examples:
            "6:00A to 11:59P" -> "6a-11:59p"
            "4:00P to 7:00P" -> "4p-7p"
        """
        # Extract times
        match = re.search(r'(\d+):?(\d+)?([AP]).*?to.*?(\d+):?(\d+)?([AP])', self.time_period, re.IGNORECASE)
        if not match:
            return self.time_period
        
        start_hour, start_min, start_ampm, end_hour, end_min, end_ampm = match.groups()
        
        # Format start time (drop :00 minutes)
        start_time = f"{start_hour}"
        if start_min and start_min != "00":
            start_time += f":{start_min}"
        start_time += start_ampm.lower()
        
        # Format end time (drop :00 minutes)
        end_time = f"{end_hour}"
        if end_min and end_min != "00":
            end_time += f":{end_min}"
        end_time += end_ampm.lower()
        
        return f"{start_time}-{end_time}"
    
    def get_language(self) -> str:
        """
        Extract language from program field.
        
        Examples:
            "CHINESE" -> "Chinese"
            "CVC CHINESE" -> "Chinese"
        """
        program_upper = self.program.upper()
        
        # Map program to language
        if 'CHINESE' in program_upper or 'MANDARIN' in program_upper or 'CANTONESE' in program_upper:
            return "Chinese"
        elif 'FILIPINO' in program_upper or 'TAGALOG' in program_upper:
            return "Filipino"
        elif 'KOREAN' in program_upper:
            return "Korean"
        elif 'VIETNAMESE' in program_upper:
            return "Vietnamese"
        elif 'HMONG' in program_upper:
            return "Hmong"
        elif 'SOUTH ASIAN' in program_upper or 'HINDI' in program_upper or 'PUNJABI' in program_upper:
            return "South Asian"
        elif 'JAPANESE' in program_upper:
            return "Japanese"
        else:
            return "Chinese"  # Default
    
    def get_description(self) -> str:
        """
        Generate line description for Etere.
        
        SAGENT Format with line numbers:
        - Paid: "(Line #) <Market> <Language>" → "(Line 1) CVC Chinese"
        - Bonus: "(Line #) BNS <Market> <Language>" → "(Line 2) BNS CVC Chinese"
        
        Examples:
            Paid: "(Line 1) CVC Chinese", "(Line 3) LAX Chinese"
            Bonus: "(Line 2) BNS CVC Chinese", "(Line 4) BNS LAX Chinese"
        """
        language = self.get_language()
        
        if self.is_bonus():
            return f"(Line {self.line_number}) BNS {self.market} {language}"
        else:
            return f"(Line {self.line_number}) {self.market} {language}"


@dataclass(frozen=True)
class SagentOrder:
    """
    Complete SAGENT order.
    
    Attributes:
        advertiser: Client name (e.g., "CAL FIRE")
        campaign: Campaign name (e.g., "2026 CAL FIRE Fourth of July")
        flight_start: Flight start date (MM/DD/YY format)
        flight_end: Flight end date (MM/DD/YY format)
        order_number: Full order number (e.g., "Cros202601282125211")
        estimate_number: Estimate number with leading zeros (e.g., "000202")
        estimate_number_stripped: Estimate without leading zeros (e.g., "202")
        buyer: Buyer name
        brand: Brand name
        week_start_dates: List of week start date strings
        lines: List of SagentLine objects
        markets: List of unique markets in order
    """
    advertiser: str
    campaign: str
    flight_start: str
    flight_end: str
    order_number: str
    estimate_number: str
    estimate_number_stripped: str
    buyer: str
    brand: str
    week_start_dates: List[str]
    lines: List[SagentLine]
    markets: List[str]
    
    def get_default_contract_code(self) -> str:
        """
        Generate default contract code.
        Format: "Sagent <Client> <Est#>"
        Example: "Sagent Cal Fire 202"
        """
        return f"Sagent {self.advertiser} {self.estimate_number_stripped}"
    
    def get_default_description(self) -> str:
        """
        Generate default contract description.
        Format: "<Client> <Campaign> Est <Est#>"
        Example: "Cal Fire 2026 CAL FIRE Fourth of July Est 202"
        """
        return f"{self.advertiser} {self.campaign} Est {self.estimate_number_stripped}"
    
    def get_default_notes(self) -> str:
        """
        Generate default notes.
        Format: "Est <Est#>"
        Example: "Est 202"
        """
        return f"Est {self.estimate_number_stripped}"
    
    def get_lines_by_market(self, market: str) -> List[SagentLine]:
        """Get all lines for a specific market."""
        return [line for line in self.lines if line.market.upper() == market.upper()]


def gross_up_rate(net_rate: float) -> Decimal:
    """
    Gross up net rate by dividing by 0.85.
    
    Args:
        net_rate: Net rate from PDF
        
    Returns:
        Grossed rate rounded to 2 decimals
        
    Examples:
        >>> gross_up_rate(21.25)
        Decimal('25.00')
        
        >>> gross_up_rate(49.56)
        Decimal('58.31')
    """
    if net_rate == 0:
        return Decimal("0.00")
    
    net_decimal = Decimal(str(net_rate))
    gross_rate = net_decimal / Decimal("0.85")
    
    # Round to 2 decimal places
    return gross_rate.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)


def normalize_market_code(market: str) -> str:
    """
    Normalize market name to standard code.
    
    Args:
        market: Market name from PDF (e.g., "LA", "CVC", "SF")
        
    Returns:
        Standardized market code (e.g., "LAX", "CVC", "SFO")
    """
    market_upper = market.upper().strip()
    
    mapping = {
        "LA": "LAX",
        "LAX": "LAX",
        "LOS ANGELES": "LAX",
        "SF": "SFO",
        "SFO": "SFO",
        "SAN FRANCISCO": "SFO",
        "CVC": "CVC",
        "CENTRAL VALLEY": "CVC",
        "SACRAMENTO": "CVC",
        "SEA": "SEA",
        "SEATTLE": "SEA",
        "NYC": "NYC",
        "NEW YORK": "NYC",
        "HOU": "HOU",
        "HOUSTON": "HOU",
        "CMP": "CMP",
        "CHICAGO": "CMP",
        "MINNEAPOLIS": "CMP",
        "WDC": "WDC",
        "WASHINGTON": "WDC",
        "DC": "WDC",
        "MMT": "MMT",
        "MULTIMARKET": "MMT",
    }
    
    return mapping.get(market_upper, market_upper)


def parse_sagent_pdf(pdf_path: str) -> SagentOrder:
    """
    Parse SAGENT order PDF.
    
    SAGENT PDFs have a unique multi-line format where each order line
    spans 2-3 text lines:
    Line 1: Line# Length Rate Market Program Week1 Week2 Week3 Total DP GRI NetCost
    Line 2: Time Period
    Line 3: Days
    
    Args:
        pdf_path: Path to PDF file
        
    Returns:
        SagentOrder object with all parsed data
        
    Raises:
        ValueError: If PDF cannot be parsed
    """
    print(f"\n[PARSER] Reading SAGENT PDF: {pdf_path}")
    
    with pdfplumber.open(pdf_path) as pdf:
        # Extract text from first page
        first_page = pdf.pages[0]
        full_text = first_page.extract_text()
        
        # Parse header information
        advertiser = _extract_field(full_text, r'ADVERTISER:\s*([^\n]+)')
        # Remove "REV: 0" suffix if present
        advertiser = re.sub(r'\s+REV:\s*\d+', '', advertiser).strip()
        
        campaign = _extract_field(full_text, r'CAMPAIGN:\s*([^\n]+)')
        # Remove "ORDER #:" suffix if present
        campaign = re.sub(r'\s+ORDER #:.*', '', campaign).strip()
        
        flight_dates = _extract_field(full_text, r'FLIGHT DATES:\s*([^\n]+)')
        # Remove "VENDOR:" suffix if present
        flight_dates = re.sub(r'\s+VENDOR:.*', '', flight_dates).strip()
        
        order_number = _extract_field(full_text, r'ORDER #:\s*([^\n]+)')
        estimate_number = _extract_field(full_text, r'Estimate #:\s*([^\n]+)')
        buyer = _extract_field(full_text, r'Buyer:\s*([^\n]+)')
        brand = _extract_field(full_text, r'Brand:\s*([^\n]+)')
        
        # Parse flight dates
        flight_start, flight_end = _parse_flight_dates(flight_dates)
        
        # Strip leading zeros from estimate
        estimate_stripped = estimate_number.lstrip('0')
        
        print(f"[PARSER] Advertiser: {advertiser}")
        print(f"[PARSER] Campaign: {campaign}")
        print(f"[PARSER] Flight: {flight_start} - {flight_end}")
        print(f"[PARSER] Order #: {order_number}")
        print(f"[PARSER] Estimate: {estimate_number} (stripped: {estimate_stripped})")
        
        # Extract week header dates
        # Header looks like: "Jun   Jun   Jun   Tot"
        # But there might be another header line in between
        # So we need to search the next few lines for one containing "Spots"
        
        week_start_dates = []
        lines_list = full_text.split('\n')
        
        for idx, line in enumerate(lines_list):
            # Look for the specific week header line
            # Must have: 3+ months AND "Tot" (for Total column)
            months = re.findall(r'\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\b', line)
            
            if len(months) >= 3 and 'Tot' in line:
                print(f"[PARSER] Found month header: {line}")
                print(f"[PARSER] Months found: {months}")
                
                # Search next few lines for one containing "Spots"
                for offset in range(1, 5):  # Check next 4 lines
                    if idx + offset < len(lines_list):
                        day_line = lines_list[idx + offset]
                        print(f"[PARSER] Checking line +{offset}: {day_line}")
                        
                        # Check if this line has "Spots" to confirm it's the day line
                        if 'Spots' in day_line or 'spots' in day_line.lower():
                            print(f"[PARSER] Found day line with 'Spots': {day_line}")
                            
                            # Extract all numbers from the day line
                            # They should be 1-2 digits
                            day_numbers = re.findall(r'\b(\d{1,2})\b', day_line)
                            print(f"[PARSER] Days found: {day_numbers}")
                            
                            # Match first 3 months with first 3 day numbers
                            if len(day_numbers) >= 3:
                                for month, day in zip(months[:3], day_numbers[:3]):
                                    week_start_dates.append(f"{month} {day}")
                                
                                print(f"[PARSER] Week start dates: {week_start_dates}")
                                break
                
                if week_start_dates:
                    break
        
        if not week_start_dates:
            print(f"[PARSER] WARNING: Could not parse week columns - will use contract dates")
        
        print(f"[PARSER] Week columns: {week_start_dates}")
        
        # Parse line items using text patterns
        lines = []
        markets_set = set()
        
        # Split text into lines
        text_lines = full_text.split('\n')
        
        # Find where the data lines start (after header)
        data_start_idx = 0
        for idx, line in enumerate(text_lines):
            if re.match(r'^\d+\s+:', line):  # Line starting with number and colon (e.g., "1   :15")
                data_start_idx = idx
                break
        
        # Parse each order line
        # Structure is:
        # Line N:   Time Period (e.g., "6:00A to 11:59P")
        # Line N+1: Line# :Length $Rate Market Program Spots...
        # Line N+2: Days (e.g., "M T W R F Sa Su")
        
        idx = data_start_idx
        while idx < len(text_lines):
            line_text = text_lines[idx].strip()
            
            # Check if this is a line number (e.g., "1   :15   $21.25...")
            line_match = re.match(r'^(\d+)\s+(:?\d+)\s+\$([0-9.]+)\s+(\w+)\s+(.+)', line_text)
            
            if line_match:
                line_number = int(line_match.group(1))
                length = line_match.group(2)
                net_rate_str = line_match.group(3)
                market = line_match.group(4)
                rest_of_line = line_match.group(5)
                
                # Parse the rest: "PROGRAM   WEEK1 WEEK2 WEEK3 TOTAL DP GRI NETCOST"
                # Extract program name (before the numbers)
                program_match = re.match(r'^(\w+(?:\s+\w+)*?)\s+(\d+)', rest_of_line)
                if program_match:
                    program = program_match.group(1).strip()
                    
                    # Extract weekly spots (3 numbers before "Tot Spots")
                    spot_match = re.findall(r'\b(\d+)\b', rest_of_line)
                    if len(spot_match) >= 3:
                        weekly_spots = [int(spot_match[0]), int(spot_match[1]), int(spot_match[2])]
                    else:
                        weekly_spots = [0, 0, 0]
                else:
                    program = rest_of_line.split()[0] if rest_of_line else "UNKNOWN"
                    weekly_spots = [0, 0, 0]
                
                # PREVIOUS line: Time Period
                time_period = ""
                if idx - 1 >= 0:
                    time_period = text_lines[idx - 1].strip()
                    # Verify it looks like a time period
                    if not re.search(r'\d+:\d+[AP]', time_period):
                        time_period = "6:00A to 11:59P"  # Default if not found
                
                # NEXT line: Days
                days = ""
                if idx + 1 < len(text_lines):
                    days_text = text_lines[idx + 1].strip()
                    # Check if this looks like days
                    if re.match(r'^[MTWRFS]', days_text):
                        days = days_text
                
                # If no days found, default to M-Su
                if not days:
                    days = "M T W R F Sa Su"
                
                # Parse net rate
                net_rate = float(net_rate_str)
                
                # Gross up rate
                gross_rate = gross_up_rate(net_rate)
                
                # Normalize market
                market_normalized = normalize_market_code(market)
                markets_set.add(market_normalized)
                
                # Calculate total spots
                total_spots = sum(weekly_spots)
                
                # Create line
                line = SagentLine(
                    line_number=line_number,
                    time_period=time_period,
                    days=days,
                    length=length,
                    net_rate=Decimal(str(net_rate)),
                    gross_rate=gross_rate,
                    market=market_normalized,
                    program=program,
                    weekly_spots=weekly_spots,
                    total_spots=total_spots
                )
                
                lines.append(line)
                
                print(f"[PARSER] Line {line_number}: {market_normalized} {program} - "
                      f"${net_rate} net → ${gross_rate} gross - {total_spots} spots")
                
                # Move to next line (we already processed current and next)
                idx += 1
            else:
                idx += 1
        
        if not lines:
            raise ValueError("No lines parsed from PDF")
        
        markets = sorted(list(markets_set))
        
        return SagentOrder(
            advertiser=advertiser,
            campaign=campaign,
            flight_start=flight_start,
            flight_end=flight_end,
            order_number=order_number,
            estimate_number=estimate_number,
            estimate_number_stripped=estimate_stripped,
            buyer=buyer,
            brand=brand,
            week_start_dates=week_start_dates,
            lines=lines,
            markets=markets
        )


def _extract_field(text: str, pattern: str) -> str:
    """Extract field using regex pattern."""
    match = re.search(pattern, text, re.MULTILINE | re.IGNORECASE)
    if match:
        return match.group(1).strip()
    return ""


def _parse_flight_dates(flight_dates: str) -> Tuple[str, str]:
    """
    Parse flight date range.
    
    Args:
        flight_dates: Date range string (e.g., "06/08/26 - 07/04/26")
        
    Returns:
        Tuple of (start_date, end_date) in MM/DD/YYYY format
    """
    # Split on dash
    parts = flight_dates.split('-')
    if len(parts) != 2:
        raise ValueError(f"Invalid flight dates format: {flight_dates}")
    
    start = parts[0].strip()
    end = parts[1].strip()
    
    # Convert MM/DD/YY to MM/DD/YYYY
    start_formatted = _format_date(start)
    end_formatted = _format_date(end)
    
    return start_formatted, end_formatted


def _format_date(date_str: str) -> str:
    """
    Convert MM/DD/YY to MM/DD/YYYY.
    
    Args:
        date_str: Date string (e.g., "06/08/26")
        
    Returns:
        Formatted date (e.g., "06/08/2026")
    """
    parts = date_str.split('/')
    if len(parts) != 3:
        return date_str
    
    month, day, year = parts
    
    # Convert 2-digit year to 4-digit
    if len(year) == 2:
        year_int = int(year)
        if year_int >= 0 and year_int <= 50:
            year = f"20{year}"
        else:
            year = f"19{year}"
    
    return f"{month}/{day}/{year}"


def analyze_weekly_distribution(
    weekly_spots: List[int],
    week_start_dates: List[str],
    contract_end_date: str
) -> List[dict]:
    """
    Analyze weekly spot distribution and create date ranges.
    
    UNIVERSAL RULE: Combine consecutive weeks with identical spot counts.
    
    Args:
        weekly_spots: List of spots per week (e.g., [72, 72, 0])
        week_start_dates: List of week start dates (e.g., ["Jun 15", "Jun 22", "Jun 29"])
        contract_end_date: Contract end date (MM/DD/YYYY format)
        
    Returns:
        List of dictionaries with combined date ranges
    """
    ranges = []
    
    # If we have proper week dates, create ranges with consecutive week combining
    if week_start_dates and len(week_start_dates) >= len(weekly_spots):
        i = 0
        while i < len(weekly_spots):
            spots = weekly_spots[i]
            
            if spots == 0:
                i += 1
                continue  # Skip weeks with no spots
            
            # Start a new range
            range_start_idx = i
            range_spots = spots
            
            # Look ahead to combine consecutive weeks with same spot count
            j = i + 1
            while j < len(weekly_spots) and weekly_spots[j] == range_spots:
                j += 1
            
            range_end_idx = j - 1  # Last week with same spot count
            
            # Convert dates
            start_date = _convert_week_date_to_full(
                week_start_dates[range_start_idx], 
                contract_end_date
            )
            
            # End date is either:
            # - Day before next different week starts, or
            # - Contract end date if this is the last range
            if range_end_idx < len(week_start_dates) - 1:
                # There's a next week - end day before it starts
                next_week_date = _convert_week_date_to_full(
                    week_start_dates[range_end_idx + 1],
                    contract_end_date
                )
                end_date = _subtract_one_day(next_week_date)
            else:
                # Last range - use contract end
                end_date = contract_end_date
            
            num_weeks = range_end_idx - range_start_idx + 1
            
            ranges.append({
                'start_date': start_date,
                'end_date': end_date,
                'spots_per_week': range_spots,
                'weeks': num_weeks
            })
            
            # Move to next different week
            i = j
    else:
        # Fallback: combine all weeks into single range
        total_spots = sum(weekly_spots)
        num_active_weeks = sum(1 for spots in weekly_spots if spots > 0)
        
        if total_spots > 0 and num_active_weeks > 0:
            spots_per_week = total_spots // num_active_weeks
            
            ranges.append({
                'start_date': contract_end_date,  # Placeholder - automation uses contract dates
                'end_date': contract_end_date,
                'spots_per_week': spots_per_week,
                'weeks': 1
            })
    
    return ranges


def _convert_week_date_to_full(week_date: str, reference_date: str) -> str:
    """
    Convert week date like 'Jun 15' to full MM/DD/YYYY format.
    
    Args:
        week_date: Week date (e.g., "Jun 15")
        reference_date: Reference date for year (MM/DD/YYYY)
        
    Returns:
        Full date (MM/DD/YYYY)
    """
    # Extract year from reference
    year = reference_date.split('/')[-1]
    
    # Parse month and day
    month_name, day = week_date.split()
    
    month_map = {
        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
    }
    
    month_num = month_map.get(month_name, '01')
    
    return f"{month_num}/{day.zfill(2)}/{year}"


def _add_days_to_week_date(week_date: str, days: int) -> str:
    """
    Add days to a week date.
    
    Args:
        week_date: Week date (e.g., "Jun 15")
        days: Number of days to add
        
    Returns:
        New date (MM/DD/YYYY format - approximated)
    """
    # Parse month and day
    month_name, day = week_date.split()
    day_num = int(day)
    
    # Simple addition (assumes month doesn't overflow)
    new_day = day_num + days
    
    month_map = {
        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
    }
    
    month_num = month_map.get(month_name, '01')
    
    # Use current year (2026 for SAGENT orders)
    return f"{month_num}/{new_day:02d}/2026"


def _subtract_one_day(date_str: str) -> str:
    """
    Subtract one day from a date.
    
    Args:
        date_str: Date in MM/DD/YYYY format
        
    Returns:
        New date in MM/DD/YYYY format
    """
    from datetime import datetime, timedelta
    
    # Parse the date
    date_obj = datetime.strptime(date_str, '%m/%d/%Y')
    
    # Subtract one day
    new_date = date_obj - timedelta(days=1)
    
    # Format back to MM/DD/YYYY
    return new_date.strftime('%m/%d/%Y')


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python sagent_parser.py <pdf_path>")
        sys.exit(1)
    
    pdf_path = sys.argv[1]
    
    try:
        order = parse_sagent_pdf(pdf_path)
        
        print("\n" + "="*70)
        print("SAGENT ORDER SUMMARY")
        print("="*70)
        print(f"Advertiser: {order.advertiser}")
        print(f"Campaign: {order.campaign}")
        print(f"Flight: {order.flight_start} - {order.flight_end}")
        print(f"Order #: {order.order_number}")
        print(f"Estimate: {order.estimate_number} (stripped: {order.estimate_number_stripped})")
        print(f"Markets: {', '.join(order.markets)}")
        print(f"\nDefault Contract Code: {order.get_default_contract_code()}")
        print(f"Default Description: {order.get_default_description()}")
        print(f"Default Notes: {order.get_default_notes()}")
        print(f"\nTotal Lines: {len(order.lines)}")
        print(f"Total Spots: {sum(line.total_spots for line in order.lines)}")
        
        print("\n" + "="*70)
        print("LINES")
        print("="*70)
        for line in order.lines:
            print(f"\nLine {line.line_number}: {line.market} {line.program}")
            print(f"  Time: {line.time_period}")
            print(f"  Days: {line.days}")
            print(f"  Rate: ${line.net_rate} net → ${line.gross_rate} gross")
            print(f"  Spots: {line.weekly_spots} = {line.total_spots} total")
            print(f"  Description: {line.get_description()}")
        
    except Exception as e:
        print(f"\n✗ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
