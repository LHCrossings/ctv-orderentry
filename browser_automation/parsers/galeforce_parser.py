"""
GaleForceMedia Generic Order Parser

Parses orders generated by GaleForceMedia for agencies other than Sagent
(e.g. BMO/PACO Collective, BO-3189).

PDF Layout (text-based — NOT a grid table):
  Header block:
    ORDER <Agency>
    ADVERTISER: <Client>
    CAMPAIGN: <Campaign>   ORDER #: <OrderNum> Phone:
    FLIGHT DATES:<start> - <end>
    VENDOR: Crossings TV  Estimate #:<EstNum>
    MARKET: <MarketName>

  Column header (3 text lines):
    Line  Time Period  Net  Program  <Mon1>  <Mon2> ... Tot
    Len   DP           Net Cost
    #     Days Rate    Comments  <d1>  <d2> ...  Spots

  Line items (multi-line groups):
    [program_continuation]   ← optional, ALL CAPS text, no digits
    <time_period>            ← "8:00A to 9:00A"
    <line_data>              ← "1 :30 $100.00 PROGRAM ... w1 w2 ... total $cost"
    <days>                   ← "M T W R F"
    [Time: comments]         ← optional, e.g. "Time: 4p-5p; 6p-7p"

Key Business Rules:
- Bonus lines: net_rate == 0 AND total_spots > 0
- Description: "{etere_days} {etere_time} {program.title()}" + "BNS " prefix for bonus
- Gross-up: optional (ask per order), applied as net / 0.85
- Market: single, from MARKET header field, normalised via normalize_market_code()
- Week consolidation: via EtereClient.consolidate_weeks()
"""

from dataclasses import dataclass
from decimal import Decimal, ROUND_HALF_UP
from typing import List, Tuple, Optional
from pathlib import Path
import re
import sys

_project_root = Path(__file__).parent.parent.parent
if str(_project_root) not in sys.path:
    sys.path.insert(0, str(_project_root))

import pdfplumber

from browser_automation.parsers.sagent_parser import normalize_market_code


# ─────────────────────────────────────────────────────────────────────────────
# DATACLASSES
# ─────────────────────────────────────────────────────────────────────────────

@dataclass(frozen=True)
class GaleForceLine:
    """
    A single line item from a GaleForceMedia order.

    Attributes:
        line_number:   Line number from PDF
        time_period:   Time range as printed in PDF (e.g. "8:00A to 9:00A")
        days:          Day pattern from PDF (e.g. "M T W R F")
        length:        Spot duration (e.g. ":30", ":10")
        net_rate:      Net rate from PDF (0.00 for bonus lines)
        program:       Program name, daypart codes stripped (e.g. "KOREAN NEWS")
        weekly_spots:  Spots per week column
        total_spots:   Sum of weekly_spots (or explicit total from PDF)
        is_bonus:      True when net_rate == 0 and total_spots > 0
    """
    line_number: int
    time_period: str
    days: str
    length: str
    net_rate: Decimal
    program: str
    weekly_spots: List[int]
    total_spots: int
    is_bonus: bool

    def get_etere_days(self) -> str:
        """
        Convert PDF day pattern to Etere abbreviated format.

        "M T W R F Sa Su" → "M-Su"
        "M T W R F"       → "M-F"
        "Sa Su"           → "Sa-Su"
        """
        days_list = self.days.split()
        if days_list == ['M', 'T', 'W', 'R', 'F', 'Sa', 'Su']:
            return "M-Su"
        if days_list == ['M', 'T', 'W', 'R', 'F']:
            return "M-F"
        if days_list == ['Sa', 'Su']:
            return "Sa-Su"
        return ' '.join(days_list)

    def get_etere_time(self) -> str:
        """
        Convert PDF time (e.g., "8:00A to 9:00A") to Etere short format.

        "8:00A to 9:00A"   → "8a-9a"
        "4:00P to 7:00P"   → "4p-7p"
        "12:00A to 12:00A" → "12a-12a"
        """
        match = re.search(
            r'(\d+):?(\d+)?([AP]).*?to.*?(\d+):?(\d+)?([AP])',
            self.time_period,
            re.IGNORECASE,
        )
        if not match:
            return self.time_period

        sh, sm, sa, eh, em, ea = match.groups()

        def _fmt(h: str, m: Optional[str], ampm: str) -> str:
            t = h
            if m and m != "00":
                t += f":{m}"
            t += ampm.lower()
            return t

        return f"{_fmt(sh, sm, sa)}-{_fmt(eh, em, ea)}"

    def get_duration_seconds(self) -> int:
        """Convert ':30' → 30, ':15' → 15, ':10' → 10, etc."""
        m = re.search(r':(\d+)', self.length)
        return int(m.group(1)) if m else 30

    def get_description(self, etere_days: str, etere_time: str) -> str:
        """
        Build Etere line description.

        Format: "{etere_days} {etere_time} {program.title()}"
        Bonus prefix "BNS " unless "BONUS" already in program name.

        Examples:
            Paid:  "M-F 8a-9a Korean News"
            Bonus (no BONUS in name): "M-Su 12a-12a BNS Filipino"
            Bonus (BONUS in name):    "M-Su 12a-12a Korean Ros Bonus"
        """
        program_title = self.program.title()

        if self.is_bonus and "bonus" not in self.program.lower():
            return f"{etere_days} {etere_time} BNS {program_title}"

        return f"{etere_days} {etere_time} {program_title}"


@dataclass(frozen=True)
class GaleForceOrder:
    """
    Complete parsed GaleForceMedia order.

    Attributes:
        advertiser:        Client name (e.g. "BMO")
        campaign:          Campaign name (e.g. "26-BMO-00102 2026 BMO LA")
        flight_start:      MM/DD/YYYY
        flight_end:        MM/DD/YYYY
        market:            Normalised market code (e.g. "LAX")
        order_number:      Order number (e.g. "BO-3189")
        estimate_number:   With leading zeros (e.g. "000027")
        estimate_stripped: Without leading zeros (e.g. "27")
        agency:            Ordering agency (e.g. "PACO Collective")
        week_start_dates:  Week column header dates (e.g. ["Apr 27", "May 04"])
        lines:             Parsed line items
    """
    advertiser: str
    campaign: str
    flight_start: str
    flight_end: str
    market: str
    order_number: str
    estimate_number: str
    estimate_stripped: str
    agency: str
    week_start_dates: List[str]
    lines: List[GaleForceLine]

    def get_default_contract_code(self) -> str:
        """e.g. "BMO 27" """
        return f"{self.advertiser} {self.estimate_stripped}"

    def get_default_description(self) -> str:
        """e.g. "BMO 26-BMO-00102 2026 BMO LA" """
        return f"{self.advertiser} {self.campaign}"

    def get_default_notes(self) -> str:
        """e.g. "Est 27" """
        return f"Est {self.estimate_stripped}"


# ─────────────────────────────────────────────────────────────────────────────
# HELPERS
# ─────────────────────────────────────────────────────────────────────────────

def _extract_field(text: str, pattern: str) -> str:
    """Extract first capture group from text, or ''."""
    m = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
    return m.group(1).strip() if m else ""


def _parse_flight_dates(raw: str) -> Tuple[str, str]:
    """
    Parse "MM/DD/YY - MM/DD/YY" or "MM/DD/YYYY - MM/DD/YYYY".
    Returns (start, end) as MM/DD/YYYY strings.
    """
    # Split on " - " to avoid ambiguity with month ranges
    parts = re.split(r'\s*-\s*', raw.strip())
    if len(parts) < 2:
        raise ValueError(f"Cannot parse flight dates: {raw!r}")

    start = parts[0].strip()
    end = parts[-1].strip()

    def _to_4y(d: str) -> str:
        p = d.split('/')
        if len(p) != 3:
            return d
        mm, dd, yy = p
        if len(yy) == 2:
            yy = f"20{yy}" if int(yy) <= 50 else f"19{yy}"
        return f"{mm}/{dd}/{yy}"

    return _to_4y(start), _to_4y(end)


# Known 2-letter daypart codes that GaleForceMedia appends to program names.
# These are NOT part of the program name and should be stripped.
_DAYPART_CODES = {'EM', 'DT', 'WE', 'EF', 'PT', 'LN', 'EA', 'PM', 'EV', 'LA',
                  'MO', 'AF', 'PN', 'LT'}


def _strip_daypart_code(program: str) -> str:
    """Strip trailing 2-letter daypart code from program name if present."""
    m = re.search(r'\s+([A-Z]{2})$', program)
    if m and m.group(1) in _DAYPART_CODES:
        return program[:m.start()].strip()
    return program


# ─────────────────────────────────────────────────────────────────────────────
# MAIN PARSER
# ─────────────────────────────────────────────────────────────────────────────

def parse_galeforce_pdf(pdf_path: str) -> GaleForceOrder:
    """
    Parse a GaleForceMedia order PDF using text-line extraction.

    Args:
        pdf_path: Path to the PDF file.

    Returns:
        GaleForceOrder dataclass with all parsed data.

    Raises:
        ValueError: If critical fields cannot be parsed.
    """
    print(f"\n[GALEFORCE PARSER] Reading: {pdf_path}")

    with pdfplumber.open(pdf_path) as pdf:
        first_page = pdf.pages[0]
        full_text = first_page.extract_text() or ""

        # ── Header fields ────────────────────────────────────────────────────
        advertiser_raw = _extract_field(full_text, r'ADVERTISER:\s*([^\n]+)')
        # Strip "REV: N" suffix (same line or adjacent)
        advertiser = re.sub(r'\s+REV:\s*\d+.*', '', advertiser_raw, flags=re.IGNORECASE).strip()

        campaign_raw = _extract_field(full_text, r'CAMPAIGN:\s*([^\n]+)')
        campaign = re.sub(r'\s+ORDER\s*#:.*', '', campaign_raw, flags=re.IGNORECASE).strip()

        flight_raw = _extract_field(full_text, r'FLIGHT\s+DATES?:\s*([^\n]+)')
        flight_raw = re.sub(r'\s+VENDOR:.*', '', flight_raw, flags=re.IGNORECASE).strip()

        order_raw = _extract_field(full_text, r'ORDER\s*#:\s*([^\n]+)')
        # Strip " Phone:..." and other trailing noise
        order_number = re.sub(r'\s+(?:Phone|Tel|Fax):.*', '', order_raw, flags=re.IGNORECASE).strip()

        estimate_raw = _extract_field(full_text, r'Estimate\s*#:\s*([^\n\s,]+)')
        estimate_stripped = estimate_raw.lstrip('0') or estimate_raw

        # Market: full phrase (may be multi-word like "Los Angeles")
        market_raw = _extract_field(full_text, r'MARKET:\s*([^\n]+)')
        # Strip trailing noise (e.g. "ATTN:", "Job #:")
        market_raw = re.split(r'\s+(?:ATTN|Job\s*#):', market_raw, flags=re.IGNORECASE)[0].strip()
        market = normalize_market_code(market_raw)

        # Agency: appears as "ORDER <Agency>" in the header block
        agency_match = re.search(r'^ORDER\s+([A-Za-z].+)$', full_text, re.MULTILINE)
        agency = agency_match.group(1).strip() if agency_match else ""

        flight_start, flight_end = _parse_flight_dates(flight_raw)

        print(f"[GALEFORCE PARSER] Advertiser:  {advertiser}")
        print(f"[GALEFORCE PARSER] Campaign:    {campaign}")
        print(f"[GALEFORCE PARSER] Flight:      {flight_start} – {flight_end}")
        print(f"[GALEFORCE PARSER] Market:      {market}")
        print(f"[GALEFORCE PARSER] Order #:     {order_number}")
        print(f"[GALEFORCE PARSER] Estimate #:  {estimate_raw} (stripped: {estimate_stripped})")
        print(f"[GALEFORCE PARSER] Agency:      {agency}")

        # ── Week column header parsing ────────────────────────────────────────
        # The header spans 3 text lines:
        #   "Line Time Period Net Program Apr May May ... Tot"  ← months
        #   "Len DP Net Cost"
        #   "# Days Rate Comments 27 04 11 ... Spots"          ← day numbers
        text_lines = full_text.split('\n')
        week_start_dates: List[str] = []
        months: List[str] = []
        month_line_idx = -1

        for idx, line in enumerate(text_lines):
            found_months = re.findall(
                r'\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\b', line
            )
            if len(found_months) >= 3 and 'Tot' in line:
                months = found_months
                month_line_idx = idx
                break

        if month_line_idx >= 0:
            for offset in range(1, 5):
                check_idx = month_line_idx + offset
                if check_idx < len(text_lines):
                    check_line = text_lines[check_idx]
                    if 'Spots' in check_line or 'spots' in check_line.lower():
                        day_nums = re.findall(r'\b(\d{1,2})\b', check_line)
                        for mon, day in zip(months, day_nums):
                            week_start_dates.append(f"{mon} {day}")
                        break

        n_weeks = len(week_start_dates)
        print(f"[GALEFORCE PARSER] Weeks ({n_weeks}): {week_start_dates}")

        # ── Line item parsing ─────────────────────────────────────────────────
        # Data line pattern: "N :duration $rate REST..."
        _DATA_LINE_RE = re.compile(r'^(\d+)\s+:(\d+)\s+\$([\d.]+)\s+(.+)$')
        _TIME_LINE_RE = re.compile(r'\d+:\d+[AP].*to.*\d+:\d+[AP]', re.IGNORECASE)

        # Valid day tokens (single or 2-letter)
        _DAY_TOKENS = {'M', 'T', 'W', 'R', 'F', 'Sa', 'Su'}

        def _is_days_line(line: str) -> bool:
            """Return True if every token in line is a valid day code."""
            if not line or re.search(r'\d', line):
                return False
            tokens = line.split()
            return bool(tokens) and all(t in _DAY_TOKENS for t in tokens)

        lines: List[GaleForceLine] = []

        for idx, line_text in enumerate(text_lines):
            data_m = _DATA_LINE_RE.match(line_text.strip())
            if not data_m:
                continue

            line_number = int(data_m.group(1))
            length      = f":{data_m.group(2)}"
            net_rate    = Decimal(data_m.group(3)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
            rest        = data_m.group(4)

            # Strip trailing "$cost" to avoid including dollar amounts in spot parsing
            rest_no_cost = re.sub(r'\s*\$[\d,]+\.?\d*\s*$', '', rest).strip()
            all_nums = re.findall(r'\b(\d+)\b', rest_no_cost)

            # Extract weekly spots + total from the end of the number list
            if n_weeks > 0 and len(all_nums) >= n_weeks + 1:
                weekly_spots = [int(x) for x in all_nums[-(n_weeks + 1):-1]]
                total_spots  = int(all_nums[-1])
            elif n_weeks > 0 and len(all_nums) == n_weeks:
                weekly_spots = [int(x) for x in all_nums]
                total_spots  = sum(weekly_spots)
            else:
                # Fallback: no week columns known
                weekly_spots = []
                total_spots  = int(all_nums[-1]) if all_nums else 0

            # Program name = text before the first digit in rest_no_cost
            first_digit = re.search(r'\d', rest_no_cost)
            program_raw = rest_no_cost[:first_digit.start()].strip() if first_digit else rest_no_cost.strip()

            # Strip trailing 2-letter daypart code (e.g. "EM", "DT", "WE", "EF")
            program = _strip_daypart_code(program_raw)

            # ── Find time period (line before this data line) ─────────────────
            time_period = ""
            for look_back in range(1, 4):
                if idx - look_back < 0:
                    break
                candidate = text_lines[idx - look_back].strip()
                if _TIME_LINE_RE.search(candidate):
                    time_period = candidate
                    # Look one further back for program continuation
                    # (e.g. "FILIPINO NEWS AND" before "4:00P to 7:00P")
                    if idx - look_back - 1 >= 0:
                        cont_line = text_lines[idx - look_back - 1].strip()
                        # Continuation: all uppercase, no digits, at least one word
                        # with 3+ letters (distinguishes "FILIPINO NEWS AND" from
                        # "M T W R F" which is the previous line's days pattern).
                        if (cont_line
                                and re.match(r'^[A-Z][A-Z\s]+$', cont_line)
                                and not re.search(r'\d', cont_line)
                                and re.search(r'\b[A-Z]{3,}\b', cont_line)):
                            program = (cont_line + " " + program).strip()
                    break

            if not time_period:
                time_period = "6:00A to 11:59P"

            # ── Find days (line after this data line) ─────────────────────────
            days = ""
            if idx + 1 < len(text_lines):
                next_line = text_lines[idx + 1].strip()
                if _is_days_line(next_line):
                    days = next_line

            if not days:
                days = "M T W R F Sa Su"

            is_bonus = (net_rate == Decimal("0.00") and total_spots > 0)

            gfl = GaleForceLine(
                line_number=line_number,
                time_period=time_period,
                days=days,
                length=length,
                net_rate=net_rate,
                program=program,
                weekly_spots=weekly_spots,
                total_spots=total_spots,
                is_bonus=is_bonus,
            )
            lines.append(gfl)

            print(f"[GALEFORCE PARSER] Line {line_number}: {program!r} "
                  f"${net_rate} {'BONUS' if is_bonus else 'PAID'} "
                  f"spots={weekly_spots} total={total_spots}")

        if not lines:
            raise ValueError("No lines parsed from GaleForceMedia PDF")

        return GaleForceOrder(
            advertiser=advertiser,
            campaign=campaign,
            flight_start=flight_start,
            flight_end=flight_end,
            market=market,
            order_number=order_number,
            estimate_number=estimate_raw,
            estimate_stripped=estimate_stripped,
            agency=agency,
            week_start_dates=week_start_dates,
            lines=lines,
        )


# ─────────────────────────────────────────────────────────────────────────────
# STANDALONE TEST ENTRY POINT
# ─────────────────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python galeforce_parser.py <pdf_path>")
        sys.exit(1)

    try:
        order = parse_galeforce_pdf(sys.argv[1])

        print("\n" + "=" * 70)
        print("GALEFORCE ORDER SUMMARY")
        print("=" * 70)
        print(f"Advertiser:  {order.advertiser}")
        print(f"Campaign:    {order.campaign}")
        print(f"Flight:      {order.flight_start} – {order.flight_end}")
        print(f"Market:      {order.market}")
        print(f"Order #:     {order.order_number}")
        print(f"Estimate:    {order.estimate_number} (stripped: {order.estimate_stripped})")
        print(f"Agency:      {order.agency}")
        print(f"Weeks ({len(order.week_start_dates)}): {order.week_start_dates}")
        print(f"\nDefault Code:  {order.get_default_contract_code()}")
        print(f"Default Desc:  {order.get_default_description()}")
        print(f"Default Notes: {order.get_default_notes()}")
        print(f"\nTotal Lines:   {len(order.lines)}")
        print(f"Total Spots:   {sum(l.total_spots for l in order.lines)}")

        print("\n" + "=" * 70)
        print("LINES")
        print("=" * 70)
        for line in order.lines:
            d = line.get_etere_days()
            t = line.get_etere_time()
            print(f"\nLine {line.line_number}: {line.program}")
            print(f"  Time:  {line.time_period}  →  {t}")
            print(f"  Days:  {line.days}  →  {d}")
            print(f"  Len:   {line.length}")
            print(f"  Rate:  ${line.net_rate}  {'BONUS' if line.is_bonus else 'PAID'}")
            print(f"  Spots: {line.weekly_spots}  total={line.total_spots}")
            print(f"  Desc:  {line.get_description(d, t)}")

    except Exception as exc:
        print(f"\n✗ Error: {exc}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
